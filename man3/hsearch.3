.\" Hey Emacs! This file is -*- nroff -*- source.
.\" Copyright 1993 Ulrich Drepper (drepper@karlsruhe.gmd.de)
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\" References consulted:
.\"     SunOS 4.1.1 man pages
.\" Modified Sat Sep 30 21:52:01 1995 by Jim Van Zandt <jrv@vanzandt.mv.com>
.\" Remarks from dhw@gamgee.acad.emich.edu Fri Jun 19 06:46:31 1998
.\" Modified 2001-12-26, 2003-11-28, 2004-05-20, aeb
.\" 2008-09-02, mtk: various additions and rewrites
.\"
.TH HSEARCH 3 2008-09-02 "GNU" "Linux Programmer's Manual"
.SH NAME
hcreate, hdestroy, hsearch, hcreate_r, hdestroy_r,
hsearch_r \- hash table management
.SH SYNOPSIS
.nf
.B #include <search.h>
.sp
.BI "int hcreate(size_t " nel );
.sp
.BI "ENTRY *hsearch(ENTRY " item ", ACTION " action );
.sp
.B "void hdestroy(void);"
.sp
.B #define _GNU_SOURCE
.br
.B #include <search.h>
.sp
.BI "int hcreate_r(size_t " nel ", struct hsearch_data *" tab );
.sp
.BI "int hsearch_r(ENTRY " item ", ACTION " action ", ENTRY **" ret ,
.BI "              struct hsearch_data *" tab );
.sp
.BI "void hdestroy_r(struct hsearch_data *" tab );
.fi
.SH DESCRIPTION
The three functions
.BR hcreate (),
.BR hsearch (),
and
.BR hdestroy ()
allow the caller to create and manage a hash table
containing entries, each of which consists of a key (a string)
and associated data.
Using these functions, only one hash table can be used at a time.
.PP
First the table must be created with the function
.BR hcreate ().
The argument \fInel\fP specifies the maximum number of entries
in the table.
(This maximum cannot be changed later, so choose it wisely.)
The function
.BR hcreate ()
may adjust this value upward to improve the
performance of the resulting hash table.
.\" e.g., in glibc it is raised to the next higher prime number
.PP
The corresponding function
.BR hdestroy ()
frees the memory occupied by the hash table.
After calling
.BR hdestroy ()
a new hash table can be created using
.BR hcreate ().

The function
.BR hsearch ()
searches the hash table for an
item with the same key as \fIitem\fP (where "the same" is determined using
.BR strcmp (3)),
and if successful returns a pointer to it.

The argument \fIitem\fP is of type \fIENTRY\fP, which is defined in
\fI<search.h>\fP as follows:
.in +4n
.sp
.nf
typedef struct entry {
    char *key;
    void *data;
} ENTRY;
.in
.fi
.sp
The field \fIkey\fP points to a null-terminated string which is the
search key.
The field \fIdata\fP points to data that is associated with that key.

The argument \fIaction\fP determines what
.BR hsearch ()
does after an unsuccessful search.
This argument must either have the value
.BR ENTER ,
meaning insert a copy of
.IR item ,
or the value
.BR FIND ,
meaning that NULL should be returned.
(If
.I action
is
.BR FIND ,
then
.I data
is ignored.)
.PP
The three functions
.BR hcreate_r (),
.BR hsearch_r (),
.BR hdestroy_r ()
are reentrant versions that allow a program to use
more than one table at the same time.
The last argument,
.IR tab ,
identifies the table.
The structure that it points to
must be zeroed before the first call to
.BR hcreate_r ().
The
.BR hsearch_r ()
function differs from
.BR hsearch ()
in that a pointer to the found item is returned in
.IR ret ,
rather than as the function result.
.SH "RETURN VALUE"
.BR hcreate ()
and
.BR hcreate_r ()
return non-zero on success.
They return 0 on error.

On success,
.BR hsearch ()
returns a pointer to an entry in the hash table.
.BR hsearch ()
returns NULL on error, that is,
if \fIaction\fP is \fBENTER\fP and
the hash table is full, or \fIaction\fP is \fBFIND\fP and \fIitem\fP
cannot be found in the hash table.
.BR hsearch_r ()
returns non-zero on success, and 0 on error.
.SH ERRORS
.LP
.BR hcreate ()
and
.BR hcreate_r ()
can fail for the following reasons:
.TP
.B EINVAL
.RB ( hcreate_r ())
.I tab
is NULL.
.TP
.B ENOMEM
Table full with \fIaction\fP set to \fBENTER\fP.
.TP
.B ESRCH
The \fIaction\fP argument is \fBFIND\fP and no corresponding element
is found in the table.
.\" hdestroy_r() can set errno to EINVAL if 'tab' is NULL.
.PP
.BR hsearch ()
and
.BR hsearch_r ()
can fail for the following reasons:
.TP
.B ENOMEM
.I action
was
.BR ENTER ,
.I key
was not found in the table,
and there was no room in the table to add a new entry.
.TP
.B ESRCH
.I action
was
.BR FIND ,
and
.I key
was not found in the table.
.PP
POSIX.1-2001 only specifies the
.B ENOMEM
error.
.SH "CONFORMING TO"
The functions
.BR hcreate (),
.BR hsearch (),
and
.BR hdestroy ()
are from SVr4, and are described in POSIX.1-2001.
The functions
.BR hcreate_r (),
.BR hsearch_r (),
.BR hdestroy_r ()
are GNU extensions.
.SH NOTES
Hash table implementations are usually more efficient when the
table contains enough free space to minimize collisions.
Typically, this means that
.I nel
should be at least 25% larger than the maximum number of elements
that the caller expects to store in the table.

The
.BR hdestroy ()
function does not free the buffers pointed to by the
.I key
and
.I data
elements of the hash table entries.
If these buffers need to be freed (perhaps because the program
is repeatedly creating and destroying hash tables,
rather than creating a single table whose lifetime
matches that of the program),
then the program must maintain bookkeeping data structures that
allow it to free them.
.SH BUGS
SVr4 and POSIX.1-2001 specify that \fIaction\fP
is significant only for unsuccessful searches, so that an \fBENTER\fP
should not do anything for a successful search.
The libc and glibc (before version 2.3)
implementations update the \fIdata\fP for the given \fIkey\fP
in this case.

Individual hash table entries can be added, but not deleted.
.SH EXAMPLE
.PP
The following program inserts 24 items into a hash table, then prints
some of them.
.nf

#include <stdio.h>
#include <stdlib.h>
#include <search.h>

char *data[] = { "alpha", "bravo", "charlie", "delta",
     "echo", "foxtrot", "golf", "hotel", "india", "juliet",
     "kilo", "lima", "mike", "november", "oscar", "papa",
     "quebec", "romeo", "sierra", "tango", "uniform",
     "victor", "whisky", "x\-ray", "yankee", "zulu"
};

int
main(void)
{
    ENTRY e, *ep;
    int i;

    hcreate(30);

    for (i = 0; i < 24; i++) {
        e.key = data[i];
        /* data is just an integer, instead of a
           pointer to something */
        e.data = (void *) i;
        ep = hsearch(e, ENTER);
        /* there should be no failures */
        if (ep == NULL) {
            fprintf(stderr, "entry failed\\n");
            exit(EXIT_FAILURE);
        }
    }

    for (i = 22; i < 26; i++) {
        /* print two entries from the table, and
           show that two are not in the table */
        e.key = data[i];
        ep = hsearch(e, FIND);
        printf("%9.9s \-> %9.9s:%d\\n", e.key,
               ep ? ep\->key : "NULL", ep ? (int)(ep\->data) : 0);
    }
    exit(EXIT_SUCCESS);
}
.fi
.SH "SEE ALSO"
.BR bsearch (3),
.BR lsearch (3),
.BR malloc (3),
.BR tsearch (3),
.BR feature_test_macros (7)
