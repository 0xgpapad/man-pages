.\" Copyright 2002 Walter Harms (walter.harms@informatik.uni-oldenburg.de)
.\" Distributed under GPL
.\" 2002-07-27 Walter Harms
.\" this was done with the help of the glibc manual
.\"
.TH ISGREATER 3  2002-07-27 "" "Linux Programmer's Manual"
.SH NAME
isgreater, isgreaterequal, isless, islessequal, islessgreater, isunordered \- macros
to test a relation
.SH SYNOPSIS
.nf
.B #include <math.h>
.sp
.B "int isgreater(x,y);"
.sp
.B "int isgreaterequal(x,y);"
.sp
.B "int isless(x,y);"
.sp
.B "int islessequal(x,y);"
.sp
.B "int islessgreater(x,y);"
.sp
.B "int isunordered(x,y);"
.fi
.sp
Compile with \fI\-std=c99\fP; link with \fI\-lm\fP.
.SH DESCRIPTION
The normal relation operations (like less) will fail if one of the
operands is NaN.
This will cause an exception.
To avoid this, C99 defines
these macros.
The macros are guaranteed to evaluate their operands only once.
The operand can be of any real floating-point type.
.TP
isgreater()
determines \fI(x)\ >\ (y)\fP without an exception
if \fIx\fP or \fIy\fP is NaN.
.TP
isgreaterequal()
determines \fI(x)\ >=\ (y)\fP without an exception
if \fIx\fP or \fIy\fP is NaN.
.TP
isless()
determines \fI(x)\ <\ (y)\fP without an exception
if \fIx\fP or \fIy\fP is NaN.
.TP
islessequal()
determines \fI(x)\ <=\ (y)\fP without an exception
if \fIx\fP or \fIy\fP is NaN.
.TP
islessgreater()
determines \fI(x)\ < (y) || (x) >\ (y)\fP
without an exception if \fIx\fP or \fIy\fP is NaN.
This macro is not equivalent to \fIx\ !=\ y\fP because that expression is
true if \fIx\fP or \fIy\fP is NaN.
.TP
isunordered()
is true if \fIx\fP or \fIy\fP is NaN and false otherwise.
.SH "CONFORMING TO"
C99.
.SH NOTES
Not all hardware supports these functions, and where it doesn't, they
will be emulated by macros.
This will give you a performance penalty.
Don't use these functions if NaN is of no concern for you.
.SH "SEE ALSO"
.BR fpclassify (3),
.BR isnan (3)
