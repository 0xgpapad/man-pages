.\" Copyright 2002 Walter Harms (walter.harms@informatik.uni-oldenburg.de)
.\" Distributed under GPL
.\" based on glibc infopages
.\" polished, aeb
.TH REMQUO 3 2007-07-26 "GNU" "Linux Programmer's Manual"
.SH NAME
remquo, remquof, remquol \- remainder and part of quotient
.SH SYNOPSIS
.nf
.B #include <math.h>
.sp
.BI "double remquo(double " x ", double " y ", int *" quo );
.br
.BI "float remquof(float " x ", float " y ", int *" quo );
.br
.BI "long double remquol(long double " x ", long double " y ", int *" quo );
.fi
.sp
Link with \fI\-lm\fP.
.sp
.in -4n
Feature Test Macro Requirements for glibc (see
.BR feature_test_macros (7)):
.in
.sp
.ad l
.BR remquo (),
.BR remquof (),
.BR remquol ():
_XOPEN_SOURCE\ >=\ 600 || _ISOC99_SOURCE; or
.I cc\ -std=c99
.ad b
.SH DESCRIPTION
These functions compute the remainder and part of the quotient
upon division of
.I x
by
.IR y .
A few bits of the quotient are stored via the
.I quo
pointer.
The remainder is returned as function value.

The value of the remainder is the same as that computed by the
.BR remainder (3)
function.

The value stored via the
.I quo
pointer has the sign of
.IR "x\ /\ y"
and agrees with the quotient in at least the low order 3 bits.

For example, \fIremquo(29.0,\ 3.0)\fP returns \-1.0 and might store 2.
Note that the actual quotient might not fit in an integer.
.\" A possible application of this function might be the computation
.\" of sin(x). Compute remquo(x, pi/2, &quo) or so.
.\"
.\" glibc, UnixWare: return 3 bits
.\" MacOS 10: return 7 bits
.SH "CONFORMING TO"
C99
.SH "SEE ALSO"
.BR fmod (3),
.BR logb (3),
.BR remainder (3)
